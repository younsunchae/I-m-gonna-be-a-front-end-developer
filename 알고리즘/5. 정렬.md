# 선택 정렬

데이터 하나를 기준으로 다른 데이터와 비교하여 자리를 바꾸는 식으로 반복 비교하는 정렬 <br/>
데이터의 개수가 N개라면 N-1회 for문을 돌게 된다.

```java
	public int[] solution (int n, int [] arr) {
		for (int i=0; i<n-1; i++) {
			for(int j=i+1; j<n; j++) {
				if(arr[i] > arr[j]) {
					// > 오름차순, <내림차순
					int temp = arr[i];
					arr[i] = arr[j];
					arr[j] = temp;
				}
			}
		}
		return arr;

	}
```

# 버블 정렬

두 개의 인접한 원소를 비교하여 정렬하는 방식 <br/>
정렬 과정에서의 원소의 이동이 마치 거품이 수면위로 올라오는 것 같다고 해서 버블 정렬,. <br/>
정렬의 대상이 되는 데이터 외에 추가적인 공간을 필요로 하지 않기 때문에 `제자리 정렬`이라고도 한다.

```java

	public int[] solution (int n, int [] arr) {
		for (int i=0; i<n-1; i++) {
			for(int j=0; j<n-i-1; j++) {
				if(arr[j] > arr[j+1]) {
					int temp = arr[j];
					arr[j] = arr[j+1];
					arr[j+1] = temp;
				}
			}
		}
		return arr;

	}
```

# 삽입 정렬

현재 비교하고자 하는 타겟과 그 이전의 원소들과 비교하며 자리를 교환하는 정렬 방법
![](https://blog.kakaocdn.net/dn/KRty3/btqOKXNAGUh/IfdJIJDJWeAfbNDHQ6eyh0/img.png)

1. 현재 타겟이 되는 숫자와 이전 위치에 있는 원소들을 비교(첫 번째 타켓은 두 번째 원소 부터 시작한다.)
2. 타겟이 되는 숫자가 이전 위치에 있던 원소보다 작다면 위치를 교환
3. 그 다음 타켓을 찾아 반복

```java
public int[] solution (int n, int [] arr) {
		for (int i=1; i<n; i++) {
			int target = arr[i];
			int j;
			for(j=i-1; j>=0; j--) {
				if(arr[j]>target) {
					arr[j+1] = arr[j];
				}
				else break;
			}
			arr[j+1] = target;
		}
		return arr;

	}
```
